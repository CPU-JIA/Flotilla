# Flotilla 品牌故事

> **标语：** _我们不只是托管代码，我们构建共识。_
> **Tagline:** _We don't just host code. We build consensus._

---

**版本：** 2.0.0
**最后更新：** 2025-10-28
**字数：** ~7,500 字
**阅读时间：** 约 20 分钟

---

## 目录

1. [品牌命名的秘密](#第一章品牌命名的秘密)
2. [起源：分布式协作的悖论](#第二章起源分布式协作的悖论)
3. [Raft 与团队协作的八大映射](#第三章raft-与团队协作的八大映射)
4. [工程准则：我们的技术信仰](#第四章工程准则我们的技术信仰)
5. [五个开发者的噩梦](#第五章五个开发者的噩梦)
6. [为什么不是 GitHub/GitLab？](#第六章为什么不是-githubgitlab)
7. [技术栈即信念声明](#第七章技术栈即信念声明)
8. [开源的三大支柱](#第八章开源的三大支柱)
9. [2030 年的协作画面](#第九章2030-年的协作画面)
10. [加入我们](#第十章加入我们)

---

## 第一章：品牌命名的秘密

### 1.1 Flotilla：小型舰队的隐喻

**Flotilla** 这个词来自西班牙语 _flota_（舰队）+ _-illa_（小型化后缀），意为"小型舰队"。在军事术语中，它指的是协同作战的小型船只编队——每艘船都是独立的、自主的，但共同服从统一指挥。

这不是随意的命名。这是一个经过深思熟虑的技术隐喻。

### 1.2 四层技术隐喻

**第一层：分布式节点如舰队编队**

想象一支由驱逐舰组成的舰队在海上航行。每艘船（Node）都有自己的动力系统、导航系统、武器系统，可以独立运作。但当它们组成编队时，力量倍增——不是因为单舰变强了，而是因为它们**协同**了。

这完美映射了 Raft 共识算法的核心机制：

- 每个节点（Node）都是独立的服务器
- 它们通过共识协议协同工作
- 即使旗舰（Leader）沉没，编队可以重新选举新的指挥舰
- 舰队的可靠性不依赖于单舰的不可摧毁，而依赖于**动态重组能力**

**第二层：敏捷灵活的开发团队**

注意，我们不叫自己 _Carrier_（航母）或 _Battleship_（战列舰），而是 _Flotilla_（小型舰队）。

这暗示了我们的目标用户：

- 不是大公司的重型组织架构（航母战斗群）
- 而是初创公司、开源项目、敏捷团队（驱逐舰编队）
- 快速响应，灵活调整，但依然强大

一艘航母需要几千人维护，一支小型舰队只需要几十人——但它可以完成同样多样化的任务。这就是我们想要赋能的团队类型。

**第三层：去中心化但有秩序**

舰队不是一艘超级大船，而是多艘小船的联合。这映射了分布式系统的**去中心化哲学**。

但去中心化不是无政府状态。舰队有指挥舰（Leader），有通信协议，有战术纪律。这些规则不是永久的——旗舰可以更换，指挥权可以转移，但在任何时刻，编队都有明确的指挥链。

这就是 Raft 的精髓：**动态共识**。每次选举都是重新确认领导权的过程，领导权是基于共识的授权，不是永久的特权。

**第四层：容错与高可用**

在海战中，一艘船失联不会导致整个舰队瘫痪。编队可以在战斗中重组、修复、继续前进。

这完美对应 Raft 的容错机制：

- N 个节点的集群可以容忍 (N-1)/2 个节点故障
- 当 Leader 宕机，系统自动选举新 Leader，无需人工干预
- 数据通过日志复制保存在多个节点上，单点故障不会丢失数据

**Flotilla = 容错、动态、协同。这就是我们的技术 DNA。**

### 1.3 品牌延伸：从命名到视觉

基于这个隐喻，我们可以延伸出完整的品牌体系：

- **Logo 设计**：三艘船的编队图形（对应典型的 3-node Raft cluster）
- **术语体系**：
  - Node → Ship（船只）
  - Leader → Flagship（旗舰）
  - Cluster → Fleet（舰队）
  - Heartbeat → Signal Flag（信号旗）
- **Slogan 变体**：
  - _"We sail together."_（我们同舟共济）
  - _"One fleet, one truth."_（一支舰队，一个真相）

---

## 第二章：起源：分布式协作的悖论

### 2.1 核心问题

当软件团队分散在全球各地，我们已经掌握了**分布式系统**的技术——数据可以在多个数据中心之间复制，服务可以跨越大洲部署，CAP 定理、一致性哈希、分布式事务，这些问题都有成熟的解决方案。

但讽刺的是，我们依然在**分布式协作**上陷入混乱：

- 代码冲突（Merge Conflicts）
- 权限纠纷（Permission Disputes）
- 沟通误解（Communication Breakdowns）
- 决策延迟（Decision Paralysis）

这些问题的本质不是技术，而是**共识的缺失**。

### 2.2 灵感时刻

2024 年某个深夜，我在读 Raft 的论文（_In Search of an Understandable Consensus Algorithm_），突然意识到一个问题：

**如果 Raft 算法能让分布式节点达成共识，为什么不能让分布式团队也如此？**

- Raft 通过 Leader Election 解决"谁来决策"的问题
- Raft 通过 Log Replication 解决"如何同步状态"的问题
- Raft 通过 Majority Quorum 解决"怎样避免独裁和僵局"的问题

团队协作的本质问题不就是这些吗？

那一刻，Flotilla 的愿景诞生了：**让分布式团队像分布式系统一样可靠地协作。**

### 2.3 学术严谨 + 生产就绪

这不是一个周末项目。这是一个遵循完整软件工程生命周期的学术实践：

**需求分析 → 架构设计 → 实现 → 测试 → 文档化**

- 每一行代码都有设计文档支撑（`/docs` 目录下的 8 份设计文档）
- 每一个功能都有测试覆盖（12,534 行测试代码，覆盖率 >70%）
- 每一个决策都遵循 **ECP 工程准则**（SOLID、DRY、KISS、防御性编程）

我们既写论文级文档，也写生产级代码。**不选边站，两者都要。**

---

## 第三章：Raft 与团队协作的八大映射

Raft 不只是一个算法，它是一个关于如何达成共识的**哲学系统**。下面是 Raft 的 8 个核心机制与团队协作的深层映射。

### 3.1 Leader Election → 动态领导权

**Raft 机制：**
当 Leader 宕机，Follower 发起选举（Election），获得多数票者成为新 Leader。Leader 不是永久的，而是基于 Term（任期）的动态角色。

**团队映射：**
当项目负责人离职，团队成员可以通过贡献度、信任度自然产生新的负责人。领导权不是永久的头衔，而是基于共识的动态授权。

**哲学：** _领导权是租约，不是所有权。_

**痛点解决：**
传统公司的管理层调整需要漫长的行政流程（"谁来接任？""需要 CEO 批准吗？"）。开源项目可以快速自组织——当 Maintainer 不活跃时，活跃的 Contributor 自然接过责任。

---

### 3.2 Log Replication → 知识同步

**Raft 机制：**
Leader 将操作日志复制到所有 Follower，确保状态一致。每个节点的日志序列必须相同。

**团队映射：**
代码提交（Commit）、设计文档（Design Doc）、会议纪要（Meeting Notes）需要同步到所有成员，确保信息对齐。

**哲学：** _透明度是共识的基础。_（Transparency breeds Consensus）

**痛点解决：**
邮件线程丢失、Slack 消息被淹没、会议决议没人记录——这些都是"日志复制失败"。Flotilla 通过 Issue/PR 系统确保所有决策都有不可变的记录。

---

### 3.3 Term（任期）→ Sprint/Milestone 的周期性确认

**Raft 机制：**
每次选举产生新的 Term。旧 Term 的决策不会被承认（Stale Data 问题）。

**团队映射：**
每个 Sprint 结束后重新确认优先级。三个月前的需求文档如果没有在新 Sprint 中被重新确认，就应该被视为过期。

**哲学：** _时间是共识的边界。_

**痛点解决：**
"我们半年前讨论过这个需求"——但市场变了，技术栈变了，团队成员也变了。过期的共识比没有共识更危险。

---

### 3.4 Majority Quorum → Code Review 的审批机制

**Raft 机制：**
操作需要多数节点（N/2 + 1）确认才能提交。这避免了独裁（1 个节点决定）和僵局（所有节点都要同意）。

**团队映射：**
PR 需要 2 个 Reviewer 批准才能合并（Require 2 approvals）。不是技术负责人一个人说了算，也不需要所有人都点赞。

**哲学：** _共识不是独裁，也不是全票通过，而是多数派原则。_

**痛点解决：**
一个人说了算 → 独裁，容易出错
所有人都要同意 → 效率低下，永远达不成共识
多数派原则 → 平衡了质量和效率

---

### 3.5 Append-Only Log → Git 的不可变历史

**Raft 机制：**
日志只能追加（Append），不能修改历史（Immutability）。这保证了可审计性。

**团队映射：**
Git commit 历史不应被强制推送覆盖（No force push to main）。Branch Protection 强制执行这一规则。

**哲学：** _历史是真相，不是可以被篡改的记忆。_

**痛点解决：**
代码历史被 `git rebase` 破坏，问题根源无法追溯。"这个 bug 是谁引入的？""不知道，commit 历史被改过了。"

---

### 3.6 Heartbeat → 活跃度监控

**Raft 机制：**
Leader 定期发送心跳（Heartbeat）。Follower 超时未收到心跳则认为 Leader 失联，发起新选举。

**团队映射：**
成员长期不活跃（no commit, no review, no comment），团队需要重新分配任务或权限。

**哲学：** _沉默不是默认同意，而是失联信号。_

**痛点解决：**
成员"挂机"数周，但因为没人主动提出，项目就卡在那里。Flotilla 的活跃度统计让这种情况一目了然。

---

### 3.7 State Machine → 项目的演进路径

**Raft 机制：**
所有节点应用相同的操作序列（Log Entries），最终达到相同状态（State Machine Replication）。

**团队映射：**
所有成员遵循相同的开发流程（Branching strategy, CI/CD），确保代码库的一致性。

**哲学：** _流程是共识的具象化。_（Process is Consensus Made Concrete）

**痛点解决：**
每个人的本地环境不同，Docker 配置不同，构建命令不同——"在我机器上能跑"（Works on My Machine）。标准化流程消除了这种混乱。

---

### 3.8 Split-Brain Prevention → 分支冲突的避免

**Raft 机制：**
通过 Term 和 Log Index 防止出现两个 Leader（Split-Brain 问题）。

**团队映射：**
通过 Branch Protection 和 PR Review 防止出现两个"真相版本"（两个功能分支都自称是主分支）。

**哲学：** _单一真相来源。_（Single Source of Truth）

**痛点解决：**
两个团队分别开发，都认为自己的分支是"主线"。合并时冲突爆炸，花费数天解决。

---

### 总结陈述

> **"如果 Raft 能把混乱的网络变成可靠的状态机，为什么我们不能把混乱的团队变成可靠的交付机器？算法不只是代码，它是人类协作的隐喻。"**

---

## 第四章：工程准则：我们的技术信仰

Flotilla 的代码库遵循一套严格的工程准则，我们称之为 **ECP (Engineering & Code Principles)**。这不是可选的最佳实践，而是强制的开发规范。

### 4.1 SOLID 原则：架构设计的五大支柱

- **S - Single Responsibility**（单一职责）：每个模块只做一件事
- **O - Open/Closed**（开闭原则）：对扩展开放，对修改封闭
- **L - Liskov Substitution**（里氏替换）：子类可以替换父类
- **I - Interface Segregation**（接口隔离）：不强迫实现不需要的接口
- **D - Dependency Inversion**（依赖倒置）：依赖抽象，不依赖具体实现

这些不是口号，而是每次 Code Review 的检查项。

### 4.2 DRY 与 KISS：代码的美学

- **DRY（Don't Repeat Yourself）**：重复是万恶之源。我们主动识别和消除任何形式的代码重复。
- **KISS（Keep It Simple, Stupid）**：永远选择最简单、最清晰的实现。聪明的代码不是复杂的代码，而是简单到无法出错的代码。

### 4.3 防御性编程：永远不信任输入

- 所有外部输入（用户输入、API 响应）必须验证
- 所有 I/O 操作必须有错误处理
- 数据库查询必须防止 SQL 注入
- 用户输入必须防止 XSS 攻击

**哲学：** _在分布式系统中，一切都会失败。在团队协作中，一切都会误解。代码必须为失败而设计。_

### 4.4 测试驱动开发（TDD）

- 先写测试，后写实现（Red → Green → Refactor）
- 单元测试覆盖率 >70%
- E2E 测试覆盖核心用户流程
- 12,534 行测试代码，确保每个功能都可验证

**为什么这么严格？**

因为我们在构建一个**共识系统**。如果代码本身不可靠，团队怎么可能在它之上达成共识？

如果 Raft 的日志复制有 bug，整个集群会数据错乱。
如果 Flotilla 的 PR Review 有 bug，整个团队会决策错乱。

**可靠性不是特性，是基础。**

---

## 第五章：五个开发者的噩梦

这些不是极端案例，而是每个开发者都经历过的日常痛苦。Flotilla 不是解决技术问题，而是解决**协作中的共识问题**。

### 5.1 跨时区协作的噩梦

**痛点故事：**

> "北京时间凌晨 2 点，我收到了来自旧金山的紧急 @mention。修复了 bug 后发现伦敦团队在 6 小时前已经提交了另一个修复，但我们的方案冲突了。又花了 3 个小时在 Slack 上异步沟通，最后发现产品经理在 Notion 里早就更改了需求，但没人通知开发组。"

**Flotilla 解决方案：**

- **Notification System**：所有决策都通过 PR 流转，通知系统确保跨时区异步也不丢信息
- **Branch Protection**：避免冲突合并
- **Issue Timeline**：需求变更自动记录在 Issue 历史中

**哲学：** _异步协作需要更强的共识机制。_

---

### 5.2 权限混乱与信任危机

**痛点故事：**

> "实习生不小心 force push 到了 main 分支，覆盖了三天的工作。技术负责人说'我以为你设置了 Branch Protection'，DevOps 说'我以为你配置了 CODEOWNERS'，项目经理说'我以为这是大家的共识'。没人知道谁真正负责什么。"

**Flotilla 解决方案：**

- **Organization & Team Permissions**：分层权限体系（Org → Team → Project）
- **Branch Protection Rules**：强制执行，不可绕过
- **PR Approval Requirements**：明确记录谁批准了什么

**哲学：** _权限不是信任，而是协议。_

---

### 5.3 文档与代码的两张皮

**痛点故事：**

> "README 说这个 API 接受 JSON，代码里已经改成 Protobuf 半年了。设计文档在 Confluence，测试用例在 Jira，架构图在某个人的 Figma，没人知道哪个是最新的。开会时大家都说'我记得我们讨论过这个'，但没人能证明。"

**Flotilla 解决方案：**

- **Markdown-first Documentation**：文档和代码在同一个 repo
- **PR 强制更新文档**：代码变更必须同步更新 README
- **Git Versioning**：文档历史和代码历史一起追溯

**哲学：** _历史即真相。_

---

### 5.4 代码审查的形式主义

**痛点故事：**

> "我的 PR 等了 3 天才有人看，最后就是一个 'LGTM'（Looks Good To Me）没有任何实质性评论。合并后上线炸了，Reviewer 说'我以为你测试过了'，我说'我以为你会看代码逻辑'。Code Review 变成了走过场。"

**Flotilla 解决方案：**

- **PR Review System with Line-level Comments**：强制行级评论
- **Review 状态语义化**：APPROVED vs CHANGES_REQUESTED 有明确含义
- **Merge Status 验证**：CI 不通过 + Review 未批准 = 不能合并

**哲学：** _共识需要证据，不是形式。_

---

### 5.5 搜索代码如大海捞针

**痛点故事：**

> "我要找一个三个月前修复过的类似 bug，但不记得在哪个文件。GitHub Search 只能搜文件名，grep 太慢，最后在 Slack 里问了一圈，发现那个文件已经被重构删掉了，逻辑移到了另一个模块，但没人记录迁移路径。"

**Flotilla 解决方案：**

- **MeiliSearch Code Search**：全文搜索 + 符号提取（类、函数、变量）
- **跨项目搜索**：权限过滤，只显示你能访问的代码
- **毫秒级响应**：不需要等待，即搜即得

**哲学：** _知识应该可发现，不应靠记忆。_

---

## 第六章：为什么不是 GitHub/GitLab？

### 6.1 差异化定位矩阵

| 维度         | GitHub                    | GitLab         | Flotilla                     |
| ------------ | ------------------------- | -------------- | ---------------------------- |
| **核心哲学** | 社交化代码托管            | DevOps 全家桶  | **共识化协作**               |
| **共识算法** | 无（中心化）              | 无（中心化）   | **Raft 分布式共识**          |
| **权限模型** | RBAC（基于角色）          | RBAC           | **基于团队协议**             |
| **通知系统** | 邮件 + Webhook            | 邮件 + Webhook | **WebSocket 实时推送**       |
| **代码搜索** | ElasticSearch             | ElasticSearch  | **MeiliSearch + 符号提取**   |
| **国际化**   | 社区翻译（i18n-friendly） | 社区翻译       | **架构级双语（i18n-first）** |
| **目标用户** | 开源社区 + 企业           | 企业 DevOps    | **分布式敏捷团队**           |

### 6.2 品牌定位

**GitHub 的 Slogan：** "Where the world builds software"（全球在此构建软件）
**GitLab 的 Slogan：** "One DevOps platform"（统一 DevOps 平台）
**Flotilla 的 Slogan：** **"We don't just host code. We build consensus."**（我们不只是托管代码，我们构建共识）

### 6.3 三个核心问题

**为什么不选 GitHub？**
→ GitHub 是社交网络，Flotilla 是共识机器。

GitHub 优化的是"Star 数"和"Follower 数"，是开发者的简历。
Flotilla 优化的是"决策速度"和"共识质量"，是团队的生产力。

**为什么不选 GitLab？**
→ GitLab 是瑞士军刀，Flotilla 是手术刀。

GitLab 有 CI/CD、监控、安全扫描、项目管理……功能多到用不完。
Flotilla 只做一件事：**让协作像分布式系统一样可靠**。我们不追求功能最多，而是追求协作最可靠。

**为什么不选自建 Git 服务器？**
→ 自建是 DIY，Flotilla 是工程学。

自建 Gitea/Gogs 可以快速搭建，但你得不到：

- Raft 共识算法的分布式容错
- 基于团队的细粒度权限模型
- 符号级别的代码搜索
- 生产级的通知系统
- 学术级的文档和测试覆盖

### 6.4 我们的独特价值

**Positioning Statement:**

> "Flotilla 是第一个将分布式共识算法（Raft）应用于团队协作的代码托管平台。我们不追求功能最多，而是追求协作最可靠。如果你的团队分散在全球，如果你的项目需要学术级严谨，如果你相信共识是协作的基础——Flotilla 是为你设计的。"

---

## 第七章：技术栈即信念声明

每个技术选型都是一次信念声明。我们不选最流行的，也不选最简单的，而是选**最符合我们哲学的**。

### 7.1 Next.js 15：不妥协于过时技术

**选择：** Next.js 15（最新）
**放弃：** Create React App（已被 React 官方标记为不推荐）

**理由：**
Create React App 可以让我们快速搭建项目，但我们选择 Next.js 15——即使学习曲线更陡。

**哲学：** _短期的便利不值得用长期的技术债换取。_

---

### 7.2 Prisma：Schema 的透明性

**选择：** Prisma
**放弃：** TypeORM

**理由：**
TypeORM 用装饰器定义模型，散布在多个文件中。Prisma 用 `schema.prisma` 文件作为**单一真相来源**——所有节点看到的应该是同一个 Schema。

**哲学：** _数据模型的透明度是系统可靠性的基础。_

---

### 7.3 MeiliSearch：专注的力量

**选择：** MeiliSearch
**放弃：** ElasticSearch

**理由：**
ElasticSearch 是瑞士军刀，MeiliSearch 是手术刀。ElasticSearch 能做日志分析、时序数据、全文搜索、聚合查询……MeiliSearch 只做一件事：**快速的全文搜索**。

**哲学：** _专注产生卓越。_（就像 Raft 只解决共识问题，不尝试解决所有分布式问题）

---

### 7.4 Playwright：测试中的诚实

**选择：** Playwright
**放弃：** Cypress

**理由：**
Cypress 在浏览器内运行，可以直接访问应用的内部状态（window 对象）。Playwright 只能通过 DOM 和网络请求交互——**就像真实用户一样**。

**哲学：** _测试不应该作弊。_ 如果测试能访问内部状态，那它测试的不是用户体验，而是实现细节。

---

### 7.5 PostgreSQL：强一致性的坚守

**选择：** PostgreSQL
**放弃：** MongoDB

**理由：**
NoSQL 的口号是"最终一致性"（Eventual Consistency）。
Raft 的论文标题是"In Search of an Understandable **Consensus** Algorithm"。

我们不相信"最终一致性"。我们相信**强一致性**（Strong Consistency）。

**哲学：** _可靠性优先于速度。_ 这不是技术选择，是价值观。

---

### 7.6 元哲学：可理解的正确性

**我们的技术栈是 Raft 哲学的延伸：**

- Next.js 说：我们不妥协于过时技术
- Prisma 说：我们相信 Schema 的透明性
- MeiliSearch 说：我们相信专注的力量
- Playwright 说：我们不在测试中作弊
- PostgreSQL 说：我们不牺牲一致性

**这些工具的共同点是什么？它们都优先考虑正确性，而不是便利性。**

就像 Raft 算法：Paxos 更通用，但 Raft 更易理解；两阶段提交更简单，但 Raft 更可靠。

**可理解的正确性 > 神秘的效率。**

---

## 第八章：开源的三大支柱

### 8.1 代码即民主

**传统理念：** 开源 = 免费使用
**Flotilla 理念：** **开源 = 共识透明化**

我们开源不是因为"免费很酷"，而是因为**共识算法本身就要求透明**。

Raft 的论文说：每个节点的日志必须可审计。那么我们的代码凭什么不可审计？

如果你信任我们的代码托管你的项目，你就应该有权利审计我们的代码。

**License 选择：MIT License（最宽松）**

原因：共识算法不应该被 License 限制传播，知识应该自由流动。

**哲学：** _知识的垄断是对共识的背叛。_

---

### 8.2 贡献者优先

**传统模式：** Core Team（核心团队）vs External Contributors（外部贡献者）
**Flotilla 模式：** **只有 Contributors，没有内外之分**

在 Flotilla，我们不区分"内部开发者"和"外部贡献者"：

- 你的第 1 个 PR 被合并后，你就是 **Contributor**
- 你的第 10 个 PR 被合并后，系统自动邀请你成为 **Reviewer**
- 你的第 50 个 PR 被合并后，社区投票决定是否授予你 **Maintainer** 权限

这不是任命，而是**基于贡献的动态共识**——就像 Raft 的 Leader Election。

**贡献者权益保障：**

- 每个 Contributor 的名字永久记录在 Git 历史中（Immutable）
- Contributors 图谱自动生成（基于 Git log 分析）
- 重大决策（如更改 License）需要 Majority Quorum（多数派投票）

---

### 8.3 设计透明化

**传统模式：** 内部讨论 → 发布决定 → 社区执行
**Flotilla 模式：** **所有设计讨论都在 GitHub Issue 里公开进行**

我们没有"核心团队的私密 Slack 频道"。所有架构决策都在 GitHub Issue 里讨论：

- Issue #1: 为什么选择 NestJS 而不是 Express？
- Issue #42: Raft 实现应该用 WebSocket 还是 gRPC？
- Issue #127: 数据库索引优化策略的权衡

外部贡献者可以参与所有讨论，提出反对意见，提交替代方案。

这不是"征求意见"，而是**真正的共同设计**——就像 Raft 的 Log Replication，每个节点都有投票权。

---

## 第九章：2030 年的协作画面

### 9.1 场景 1：晨间同步

**时间：** 北京 9:00 AM（旧金山前一天 5:00 PM）

我打开 Flotilla，Notification Center 显示有 3 个 PR 待审查。不需要看 Slack，不需要刷邮件——所有需要我决策的事情都在这里。

第一个 PR 来自伦敦团队，6 小时前提交。Review Summary 已经有 2 个 APPROVED，Merge Status 显示所有 CI 通过，Branch Protection 要求 3 个审批。我是第三个。

我不需要问"这个改动会影响什么"，因为 Code Search 自动分析了依赖关系，PR 描述里自动链接了相关的 Issue #234 和设计文档。

我在第 47 行留下行级评论，建议优化算法复杂度。点击 CHANGES_REQUESTED。

30 分钟后，伦敦开发者醒了，看到通知，直接在 PR 里回复。我们不需要开会，不需要等到"大家都在线"的时间窗口。

**共识在异步中自然达成。**

---

### 9.2 场景 2：紧急修复

**时间：** 线上服务宕机，凌晨 2:00 AM

生产环境挂了。我从手机打开 Flotilla，看到 Issue #567 已经被自动创建（通过 Monitoring 集成），Severity: CRITICAL。

团队的 3 个人同时在线（北京、班加罗尔、柏林）。我们不需要在 Slack 里喊"谁在？"，Flotilla 的实时状态显示谁打开了这个 Issue。

班加罗尔同事在 Issue 评论里说"疑似数据库连接池耗尽"，贴了监控截图。我创建 Hotfix PR，直接在 commit message 里引用 Issue #567，Branch Protection 自动降级（Emergency Mode），只需要 1 个审批。

柏林同事 5 分钟内审查完毕，APPROVED + 留言"LGTM, 数据库日志也证实了连接池问题"。我点击 Merge，CI/CD 自动部署，服务恢复。

**整个过程 15 分钟，没有一句"你在吗？"，没有一次"拉个紧急会议"。**

---

### 9.3 场景 3：新人入职

**时间：** 实习生第一天

我是新加入的实习生，导师给我分配了第一个 Issue #890："修复搜索结果排序问题"。

我不知道从哪里开始，但 Issue 里已经有完整的上下文：

- 链接到设计文档（为什么需要这个排序逻辑）
- 链接到相关 PR #234（上次类似问题的修复）
- 链接到测试用例（期望行为是什么）
- 自动生成的代码位置（Code Search 找到了相关的 TypeScript 函数）

我用 Code Search 搜索 `SortAlgorithm`，找到了 3 个月前另一个实习生写的类似代码，看了他的 PR 评论，学到了团队的代码风格。

我提交 PR，设置 Draft 状态。导师在 PR 里逐行指导，不需要坐在我旁边，不需要远程桌面共享。

**所有的指导都变成了知识沉淀。**

两周后，我已经能独立完成 Issue，因为我不是在"问人"，而是在"查系统"。

---

### 9.4 场景 4：产品决策

**时间：** Feature Request 讨论，跨团队协作

产品经理在 Issue #1024 里提出新功能："支持多语言代码片段语法高亮"。

- 前端团队留言："Monaco Editor 已支持，但需要动态加载 100+ 语言包，会影响性能"
- 后端团队留言："MeiliSearch 只索引了 4 种语言，扩展需要重构 Parser"
- DevOps 留言："构建时间会增加 30%"

争论了 3 天，20 条评论，但没有人喊"开个会吧"。因为所有论据都在 Issue 里：

- 前端贴了 Monaco Editor 的 Bundle Size 分析
- 后端贴了 Parser 性能测试数据
- 产品贴了用户调研结果（80% 用户只用 JS/Python）

最后，团队长在 Issue 里总结："Phase 1 只支持 Top 4 语言，Phase 2 按需加载其他语言"。所有人点赞同意。

**这不是妥协，而是基于证据的共识。**

---

### 9.5 场景 5：开源贡献

**时间：** 外部贡献者的第一次 PR

我是一个外部贡献者，想给 Flotilla 提交一个 Bug 修复。

我不认识任何 Maintainer，但我知道流程：

1. Fork repo
2. 创建 Issue 描述问题（自动关联到相关代码）
3. 提交 PR 并引用 Issue
4. 等待 Review

我的 PR 在 6 小时内被两个 Maintainer 审查（一个在欧洲，一个在亚洲）。他们不需要问我"你是谁"，因为我的代码和测试用例说明了一切。

PR 被合并后，我自动成为 Contributors 列表的一员。下一次我提 PR，Review 会更快，因为系统记录了我的贡献历史。

**这不是"认识人好办事"，而是"代码质量决定一切"。**

---

### 9.6 愿景宣言

**2030 年，当开发者用 Flotilla 时，他们不会说"我们在用一个代码托管平台"。**

**他们会说："我们在用一个共识机器。"**

- 不需要会议，因为决策在 Issue 里自然发生
- 不需要文档管理员，因为文档和代码在同一个 repo
- 不需要信任中介，因为 Raft 算法是最公正的仲裁者
- 不需要记忆，因为历史就是真相

**这就是我们要构建的未来：协作如同呼吸一样自然，共识如同重力一样确定。**

---

## 第十章：加入我们

### Fork the repo. Read the docs. Break things. Build consensus.

**GitHub 仓库：** [github.com/CPU-JIA/Flotilla](https://github.com/CPU-JIA/Flotilla)

**文档中心：** `/docs` 目录

- [需求分析文档](./需求分析文档.md)
- [架构设计文档](./架构设计文档.md)
- [数据库设计文档](./数据库设计文档.md)
- [分布式共识算法设计方案](./分布式共识算法设计方案.md)
- [2025 战略路线图](./ROADMAP_2025.md)

**贡献指南：** [CONTRIBUTING.md](../CONTRIBUTING.md)（待完善）

**开源协议：** MIT License

**社区原则：**

1. 代码质量决定话语权，不是资历
2. 所有设计讨论公开透明
3. 基于证据的决策，不是基于权威

---

**欢迎加入 Flotilla 舰队。**

**我们不只是托管代码，我们构建共识。**

---

**版本历史：**

- v1.0.0 (2025-10-19): 初始版本
- v2.0.0 (2025-10-28): 大幅扩展内容，新增 8 个章节，字数增加 5 倍

**作者：** JIA
**审阅：** Flotilla Community
**License：** MIT

---

## 附录：使用指南

### For README.md

在 README.md 中引用品牌故事：

```markdown
📖 **[阅读品牌故事](./docs/品牌故事_ZH.md)** | **[Read Brand Story (EN)](./docs/BRAND_STORY_EN.md)**
```

### For Marketing

核心卖点提取（Elevator Pitch）：

> **"Flotilla 是第一个将 Raft 共识算法应用于团队协作的代码托管平台。我们让分布式团队像分布式系统一样可靠。"**

三个不妥协（Three Non-Negotiables）：

1. 学术严谨 + 生产就绪
2. 全球化设计（i18n-first）
3. 开发者至上

### For Pitches

**Opening：** "如果 Raft 能让节点达成共识，为什么不能让团队也如此？"

**Body：** ECP 工程准则 + 生产级 Raft + 全球化优先

**Close：** "协作应该像分布式系统一样可靠。这不是乌托邦，这是工程。"

---

**文档结束。感谢阅读。**
