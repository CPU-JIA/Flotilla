# Flotilla云端代码托管平台 - 答辩准备材料

## 一、团队分工表

| 成员 | 角色 | 主要职责 | 负责模块 | 工作量占比 |
|------|------|----------|----------|------------|
| **成员A** | 项目负责人/架构师 | 系统架构设计、技术选型、Raft算法实现、项目进度管理 | Raft共识模块、系统架构、数据库设计 | 30% |
| **成员B** | 后端开发工程师 | API设计与实现、业务逻辑开发、数据库优化 | 用户认证、项目管理、Git协议、Issue/PR模块 | 30% |
| **成员C** | 前端开发工程师 | 用户界面设计、前端交互实现、状态管理 | React组件、页面路由、WebSocket通知、UI/UX设计 | 25% |
| **成员D** | 测试/文档工程师 | 测试用例设计、UML建模、文档编写、质量保证 | 单元测试、E2E测试、UML图、需求文档、课程报告 | 15% |

### 详细分工说明

#### 成员A - 项目负责人/架构师
- 负责整体系统架构设计（前后端分离、微服务架构）
- 实现Raft分布式共识算法核心逻辑（Leader选举、日志复制）
- 设计数据库Schema（48个数据模型）
- 技术选型决策（NestJS、Next.js、PostgreSQL等）
- 协调团队开发进度，组织技术评审

#### 成员B - 后端开发工程师
- 实现用户认证模块（JWT、OAuth、2FA）
- 开发Git HTTP Smart Protocol（clone/push/fetch）
- 实现Issue追踪和Pull Request代码审查功能
- 开发组织/团队/项目三层权限系统
- API接口设计与Swagger文档

#### 成员C - 前端开发工程师
- 基于Next.js 15.5实现响应式界面
- 开发React组件库（基于Shadcn/ui）
- 实现WebSocket实时通知功能
- 状态管理（TanStack Query + Context）
- 代码差异对比（Diff）界面实现

#### 成员D - 测试/文档工程师
- 编写Jest单元测试（覆盖率70%+）
- 设计Playwright E2E测试用例
- 绘制34张UML图（用例图、类图、时序图、状态图等）
- 编写需求分析文档、架构设计文档
- 撰写UML课程报告

---

## 二、答辩问题及参考答案

### 【UML建模相关问题】

#### Q1: 请介绍一下你们项目中使用了哪些UML图？各有什么作用？

**答案：**
我们项目共使用了6种UML图，绘制了34张图：

1. **用例图（3张）**：描述系统功能需求，展示开发者、管理员、审查者等角色与系统功能的交互关系。

2. **类图（5张）**：描述系统静态结构，包括核心实体类图（User、Project、Repository等）、Raft共识类图、服务层类图等。

3. **时序图（8张）**：描述对象间的消息交互顺序，如用户认证流程、Git Push流程、Raft Leader选举过程等。

4. **状态图（5张）**：描述对象生命周期状态变化，如Raft节点状态（Follower→Candidate→Leader）、Issue生命周期、PR状态流转等。

5. **活动图（4张）**：描述业务流程，如Pull Request工作流、安全认证流程、文件上传处理等。

6. **组件图/部署图（9张）**：描述系统物理架构，包括Kubernetes部署架构、微服务通信架构、数据库读写分离等。

---

#### Q2: 你们的Raft节点状态图是如何设计的？请解释状态转换条件。

**答案：**
Raft节点有三种状态：**Follower（跟随者）**、**Candidate（候选人）**、**Leader（领导者）**。

状态转换条件：
- **Follower → Candidate**：选举超时（未收到Leader心跳）
- **Candidate → Leader**：获得集群多数票（N/2+1）
- **Candidate → Follower**：发现更高任期的Leader
- **Candidate → Candidate**：选举超时，重新发起选举
- **Leader → Follower**：发现更高任期的节点

这个设计保证了系统在任意时刻最多只有一个Leader，确保数据一致性。

---

#### Q3: 类图中的关联、聚合、组合有什么区别？你们项目中有哪些例子？

**答案：**
- **关联（Association）**：两个类之间的普通关系
  - 例：User → Issue（用户创建Issue）

- **聚合（Aggregation）**：整体与部分的关系，部分可独立存在
  - 例：Organization ◇→ Project（组织包含项目，但项目可以转移）

- **组合（Composition）**：强聚合，部分不能独立存在
  - 例：Repository ◆→ Branch（仓库包含分支，仓库删除则分支不存在）

---

### 【技术架构相关问题】

#### Q4: 为什么选择NestJS作为后端框架？相比Express有什么优势？

**答案：**
选择NestJS的原因：

1. **模块化架构**：NestJS提供类似Angular的模块化设计，便于大型项目的代码组织。我们的32个功能模块都是独立的NestJS Module。

2. **依赖注入（DI）**：内置IoC容器，便于单元测试和解耦。

3. **装饰器支持**：使用@Controller、@Injectable、@Guard等装饰器，代码更清晰。

4. **TypeScript原生支持**：完整的类型系统，减少运行时错误。

5. **企业级特性**：内置支持Guards（权限控制）、Interceptors（拦截器）、Pipes（管道验证）。

相比Express，NestJS更适合企业级应用，代码结构更规范，团队协作更高效。

---

#### Q5: 请解释一下Raft算法的基本原理，以及你们是如何实现的？

**答案：**
Raft是一种分布式共识算法，用于保证多节点数据一致性。核心机制：

1. **Leader选举**：
   - 所有节点初始为Follower
   - 选举超时后变为Candidate，向其他节点发送RequestVote
   - 获得多数票成为Leader

2. **日志复制**：
   - 客户端请求发送给Leader
   - Leader将日志条目复制到Followers
   - 多数节点确认后，Leader提交日志并应用到状态机

3. **安全性保证**：
   - 每个任期最多一个Leader
   - Leader只追加日志，不删除
   - 投票时检查日志新旧程度

我们的实现在`raft/raft-node.ts`中，包含RaftNode类、RaftTransport接口、StateMachine接口，支持心跳检测、选举超时、日志复制等功能。

---

#### Q6: Git HTTP Smart Protocol是什么？你们是如何实现的？

**答案：**
Git HTTP Smart Protocol是Git通过HTTP传输数据的协议，相比Dumb Protocol更高效。

主要端点：
- `GET /info/refs?service=git-upload-pack`：获取引用列表（clone/fetch）
- `POST /git-upload-pack`：下载对象（clone/fetch）
- `POST /git-receive-pack`：上传对象（push）

我们的实现在`git/git-http.controller.ts`：
1. 解析Git客户端请求
2. 验证用户权限
3. 使用isomorphic-git库处理Git对象
4. 将Git对象存储到MinIO
5. 更新数据库中的引用信息

---

#### Q7: 你们的权限系统是如何设计的？

**答案：**
我们采用**RBAC三层权限模型**：

**第一层 - 平台级**：
- SUPER_ADMIN：超级管理员，管理整个平台
- USER：普通用户

**第二层 - 组织/团队级**：
- OWNER：组织所有者
- ADMIN：组织管理员
- MEMBER：普通成员

**第三层 - 项目级**：
- OWNER：项目所有者
- MAINTAINER：维护者（可合并PR）
- MEMBER：开发成员（可提交代码）
- VIEWER：只读访问

权限检查通过NestJS的Guards实现，使用@Roles装饰器标注需要的权限，在请求进入Controller前进行拦截验证。

---

### 【数据库设计相关问题】

#### Q8: 你们的数据库有多少张表？核心表之间的关系是什么？

**答案：**
我们使用PostgreSQL，共有**48个数据模型**，核心关系：

```
User (1) ──→ (*) Organization ──→ (*) Project ──→ (1) Repository
  │                  │                  │
  │                  ↓                  ↓
  │              Team            Issue / PullRequest
  │                  │                  │
  └──────────────────┴──────────────────┘
                     ↓
              OrganizationMember / TeamMember / ProjectMember
```

核心表：
- **User**：用户信息、认证凭据
- **Organization**：组织/企业
- **Project**：项目，包含仓库和协作功能
- **Repository**：Git仓库，存储代码
- **Issue/PullRequest**：协作功能

使用Prisma ORM管理数据库，支持类型安全和自动迁移。

---

#### Q9: 如何保证数据库的高性能？做了哪些优化？

**答案：**
1. **索引优化**：为常用查询字段建立索引（如username、email、projectId）

2. **读写分离**：主库负责写入，从库负责读取，通过Prisma的replica配置实现

3. **连接池**：使用PgBouncer管理数据库连接，避免连接数过多

4. **缓存策略**：使用Redis缓存热点数据（用户Session、项目信息）

5. **分页查询**：所有列表接口都支持分页，避免一次加载大量数据

6. **软删除**：使用deletedAt字段实现软删除，避免物理删除带来的数据丢失风险

---

### 【前端技术相关问题】

#### Q10: 为什么选择Next.js 15？相比传统React有什么优势？

**答案：**
选择Next.js 15的原因：

1. **App Router**：新的文件系统路由，支持嵌套布局、并行路由

2. **Server Components**：部分组件在服务端渲染，减少客户端JS体积

3. **SSR/SSG支持**：首屏加载更快，SEO友好

4. **内置优化**：图片优化、字体优化、代码分割

5. **API Routes**：可以在同一项目中编写后端API

6. **Turbopack**：比Webpack快10倍的开发构建工具

相比传统React SPA，Next.js提供更好的性能和开发体验。

---

### 【安全相关问题】

#### Q11: 你们的系统采取了哪些安全措施？

**答案：**
1. **认证安全**：
   - JWT Token + Refresh Token机制
   - 密码使用Bcrypt加密（cost factor=12）
   - 支持OAuth第三方登录（GitHub/Google）
   - 两步验证（2FA TOTP）

2. **传输安全**：
   - HTTPS强制重定向
   - Security Headers（CSP、X-Frame-Options等）

3. **防护措施**：
   - CSRF Token保护
   - Rate Limiting（100请求/分钟）
   - SQL注入防护（Prisma参数化查询）
   - XSS防护（React自动转义）

4. **审计日志**：记录所有敏感操作，符合SOC2合规要求

5. **Token版本控制**：用户修改密码后，所有旧Token失效

---

### 【项目管理相关问题】

#### Q12: 你们的开发流程是怎样的？如何保证代码质量？

**答案：**
我们采用**Git Flow + CI/CD**的开发流程：

1. **分支管理**：
   - main：生产分支
   - develop：开发分支
   - feature/*：功能分支
   - hotfix/*：紧急修复分支

2. **代码审查**：所有代码通过Pull Request合并，至少一人审核

3. **自动化测试**：
   - 提交触发CI流水线
   - 运行ESLint代码检查
   - 运行Jest单元测试
   - 运行Playwright E2E测试

4. **代码质量门禁**：
   - 测试覆盖率需达到70%+
   - 无ESLint错误
   - TypeScript类型检查通过

---

#### Q13: 项目开发过程中遇到了什么困难？如何解决的？

**答案：**
主要困难和解决方案：

1. **Raft算法理解困难**
   - 阅读原始论文和etcd源码
   - 通过可视化工具理解状态转换
   - 先实现简化版，再逐步完善

2. **Git协议实现复杂**
   - 研究Git内部原理（对象模型、pack文件格式）
   - 使用isomorphic-git库辅助
   - 参考GitLab开源实现

3. **前后端联调问题**
   - 使用Swagger定义API规范
   - 前端使用Mock数据先行开发
   - 定期进行集成测试

4. **性能优化**
   - 使用React.memo减少不必要渲染
   - 实现虚拟列表优化大数据展示
   - 数据库查询优化和索引调整

---

### 【扩展性问题】

#### Q14: 如果用户量增加10倍，系统需要如何扩展？

**答案：**
我们的系统设计支持水平扩展：

1. **无状态后端**：
   - 后端服务不存储会话状态
   - Session存储在Redis中
   - 可以部署多个后端实例

2. **数据库扩展**：
   - 读写分离（主从复制）
   - 分库分表（按组织ID分片）
   - 使用连接池管理连接

3. **缓存层**：
   - Redis集群缓存热点数据
   - CDN缓存静态资源

4. **Kubernetes部署**：
   - 使用HPA自动扩缩容
   - 基于CPU/内存使用率触发扩容

5. **消息队列**：
   - 引入RabbitMQ/Kafka解耦服务
   - 异步处理耗时操作（邮件发送、Webhook推送）

---

#### Q15: 这个项目还有哪些可以改进的地方？

**答案：**
1. **功能层面**：
   - 实现代码审查的内联建议功能
   - 添加AI代码审查助手
   - 支持项目看板（Kanban）
   - 开发移动端应用

2. **技术层面**：
   - 完善Raft日志压缩（Snapshot）
   - 实现动态成员变更
   - 提升测试覆盖率至80%+
   - 添加完善的监控告警系统

3. **性能层面**：
   - 优化大文件Diff性能
   - 实现Service Worker离线支持
   - 代码搜索性能优化

---

## 三、答辩注意事项

1. **熟悉自己负责的模块**，能够深入讲解实现细节
2. **了解队友的工作**，能够回答跨模块的问题
3. **准备演示Demo**，展示核心功能（登录、创建项目、Git操作、PR流程）
4. **UML图要能解释**，特别是自己画的图
5. **诚实回答**，不懂的问题可以说"这部分我们还在学习/改进中"
